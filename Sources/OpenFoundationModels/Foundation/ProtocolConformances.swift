// ProtocolConformances.swift
// OpenFoundationModels
//
// ✅ CONFIRMED: Standard type conformances for Apple Foundation Models API

import Foundation
import OpenFoundationModelsCore

// MARK: - Standard Type Conformances

/// String conformance to Generable
/// 
/// **Apple Foundation Models Documentation:**
/// String is a fundamental type that can be generated by language models.
/// This conformance allows String to be used directly in generation methods.
/// 
/// **Source:** https://developer.apple.com/documentation/foundationmodels/generable
// String InstructionsRepresentable and PromptRepresentable conformances are in Core module

extension String: Generable {
    // Note: PartiallyGenerated defaults to Self (String)
    // No explicit typealias needed per Apple specification
    
    /// The generation schema for String content
    /// 
    /// **Apple Foundation Models Documentation:**
    /// String content uses a simple text schema for generation.
    public static var generationSchema: GenerationSchema {
        // String is a primitive Generable type, uses empty properties
        return GenerationSchema(
            type: String.self,
            description: "Text content",
            properties: []
        )
    }
    
    /// Create String from generated content
    /// 
    /// **Apple Foundation Models Documentation:**
    /// Extracts string content from generated output.
    /// ✅ CONFIRMED: Required by ConvertibleFromGeneratedContent
    public init(_ content: GeneratedContent) throws {
        self = content.text
    }
    
    /// Convert String to generated content
    /// 
    /// **Apple Foundation Models Documentation:**
    /// Converts string to generated content format.
    /// ✅ CONFIRMED: Required by ConvertibleToGeneratedContent
    public var generatedContent: GeneratedContent {
        return GeneratedContent(kind: .string(self))
    }
    
    // asPartiallyGenerated() uses default implementation from protocol extension
    // Returns self since PartiallyGenerated = String (default)
}

// GeneratedContent conformances are already defined in OpenFoundationModelsCore

extension GeneratedContent: Generable {
    // Note: PartiallyGenerated defaults to Self (GeneratedContent)
    // No explicit typealias needed per Apple specification
    
    /// The generation schema for GeneratedContent
    /// 
    /// **Apple Foundation Models Documentation:**
    /// GeneratedContent uses a flexible schema that can represent various content types.
    public static var generationSchema: GenerationSchema {
        return GenerationSchema(
            type: GeneratedContent.self,
            description: "Generated content with flexible structure",
            properties: []
        )
    }
    
    // ConvertibleFromGeneratedContent conformance is already in GeneratedContent.swift
    // ConvertibleToGeneratedContent conformance: generatedContent property is already in GeneratedContent.swift
    // asPartiallyGenerated() uses default implementation from protocol extension
}

// MARK: - Array Generable Conformance

extension Array: Generable where Element: Generable {
    /// A representation of partially generated content
    public typealias PartiallyGenerated = [Element.PartiallyGenerated]
    
    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema {
        // Array types need special handling - use Element's schema with array wrapper
        return GenerationSchema(
            type: Array<Element>.self,
            description: "Array of \(String(describing: Element.self))",
            properties: []
        )
    }
    
    /// Convert to partially generated representation
    public func asPartiallyGenerated() -> PartiallyGenerated {
        return self.map { $0.asPartiallyGenerated() }
    }
}

// MARK: - Array ConvertibleToGeneratedContent

extension Array: ConvertibleToGeneratedContent where Element: ConvertibleToGeneratedContent {
    /// An instance that represents the generated content.
    public var generatedContent: GeneratedContent {
        let elements = self.map { $0.generatedContent }
        return GeneratedContent(kind: .array(elements))
    }
}

// MARK: - Array ConvertibleFromGeneratedContent

extension Array: ConvertibleFromGeneratedContent where Element: ConvertibleFromGeneratedContent {
    /// Creates an instance with the content.
    public init(_ content: GeneratedContent) throws {
        switch content.kind {
        case .array(let elements):
            // Direct conversion from Kind.array
            self = try elements.map { try Element($0) }
        case .string(let text):
            // Backward compatibility for string parsing
            let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
            if trimmed == "[]" {
                self = []
            } else if trimmed.hasPrefix("[") && trimmed.hasSuffix("]") {
                // Try JSON array parsing
                if let data = trimmed.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [Any] {
                    self = try json.map {
                        let jsonData = try JSONSerialization.data(withJSONObject: $0)
                        let jsonString = String(data: jsonData, encoding: .utf8) ?? ""
                        return try Element(GeneratedContent(json: jsonString))
                    }
                } else {
                    // Fallback to comma-separated parsing
                    let inner = String(trimmed.dropFirst().dropLast())
                    let parts = inner.split(separator: ",").map { 
                        String($0.trimmingCharacters(in: .whitespacesAndNewlines)) 
                    }.filter { !$0.isEmpty }
                    self = try parts.map { try Element(GeneratedContent($0)) }
                }
            } else {
                // Split by commas or newlines
                let parts = text.split(whereSeparator: { $0.isNewline || $0 == "," })
                    .map { String($0.trimmingCharacters(in: .whitespacesAndNewlines)) }
                    .filter { !$0.isEmpty }
                self = try parts.map { try Element(GeneratedContent($0)) }
            }
        default:
            throw DecodingError.dataCorrupted(
                DecodingError.Context(
                    codingPath: [],
                    debugDescription: "Unable to decode Array from Kind: \(content.kind)"
                )
            )
        }
    }
}