// ProtocolConformances.swift
// OpenFoundationModels
//
// ✅ CONFIRMED: Standard type conformances for Apple Foundation Models API

import Foundation
import OpenFoundationModelsCore

// MARK: - Standard Type Conformances

/// String conformance to Generable
/// 
/// **Apple Foundation Models Documentation:**
/// String is a fundamental type that can be generated by language models.
/// This conformance allows String to be used directly in generation methods.
/// 
/// **Source:** https://developer.apple.com/documentation/foundationmodels/generable
// String InstructionsRepresentable and PromptRepresentable conformances are in Core module

extension String: Generable {
    /// Partially generated string content
    /// 
    /// **Apple Foundation Models Documentation:**
    /// Represents string content that is being generated incrementally.
    public typealias PartiallyGenerated = GeneratedContent
    
    /// The generation schema for String content
    /// 
    /// **Apple Foundation Models Documentation:**
    /// String content uses a simple text schema for generation.
    public static var generationSchema: GenerationSchema {
        // String is a primitive Generable type, uses empty properties
        return GenerationSchema(
            type: String.self,
            description: "Text content",
            properties: []
        )
    }
    
    /// Create String from generated content
    /// 
    /// **Apple Foundation Models Documentation:**
    /// Extracts string content from generated output.
    /// ✅ CONFIRMED: Required by ConvertibleFromGeneratedContent
    public init(_ content: GeneratedContent) throws {
        self = content.text
    }
    
    /// Convert String to generated content
    /// 
    /// **Apple Foundation Models Documentation:**
    /// Converts string to generated content format.
    /// ✅ CONFIRMED: Required by ConvertibleToGeneratedContent
    public var generatedContent: GeneratedContent {
        return GeneratedContent(self)
    }
    
    /// Convert to partially generated representation
    /// 
    /// **Apple Foundation Models Documentation:**
    /// Converts string to partially generated content for streaming.
    public func toPartiallyGenerated() -> PartiallyGenerated {
        return GeneratedContent(self)
    }
    
    /// Convert to partially generated representation (instance method)
    /// 
    /// **Apple Foundation Models Documentation:**
    /// Instance method for converting to partially generated content.
    public func asPartiallyGenerated() -> PartiallyGenerated {
        return GeneratedContent(self)
    }
}

// GeneratedContent conformances are already defined in OpenFoundationModelsCore

extension GeneratedContent: Generable {
    /// Partially generated content representation
    /// 
    /// **Apple Foundation Models Documentation:**
    /// GeneratedContent can represent partially generated content.
    public typealias PartiallyGenerated = GeneratedContent
    
    /// The generation schema for GeneratedContent
    /// 
    /// **Apple Foundation Models Documentation:**
    /// GeneratedContent uses a flexible schema that can represent various content types.
    public static var generationSchema: GenerationSchema {
        return GenerationSchema(
            type: GeneratedContent.self,
            description: "Generated content with flexible structure",
            properties: []
        )
    }
    
    // ConvertibleFromGeneratedContent conformance is already in GeneratedContent.swift
    // ConvertibleToGeneratedContent conformance: generatedContent property is already in GeneratedContent.swift
    
    /// Convert to partially generated representation (identity function)
    /// 
    /// **Apple Foundation Models Documentation:**
    /// Identity transformation for GeneratedContent.
    public func toPartiallyGenerated() -> PartiallyGenerated {
        return self
    }
    
    /// Convert to partially generated representation (instance method)
    /// 
    /// **Apple Foundation Models Documentation:**
    /// Instance method for converting to partially generated content.
    public func asPartiallyGenerated() -> PartiallyGenerated {
        return self
    }
}

// MARK: - Array SendableMetatype Conformance

extension Array: SendableMetatype where Element: SendableMetatype {}

// MARK: - Array Generable Conformance

extension Array: Generable where Element: Generable {
    /// A representation of partially generated content
    public typealias PartiallyGenerated = [Element.PartiallyGenerated]
    
    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema {
        // Array types need special handling - use Element's schema with array wrapper
        return GenerationSchema(
            type: Array<Element>.self,
            description: "Array of \(String(describing: Element.self))",
            properties: []
        )
    }
    
    /// Convert to partially generated representation
    public func asPartiallyGenerated() -> PartiallyGenerated {
        return self.map { $0.asPartiallyGenerated() }
    }
}

// MARK: - Array ConvertibleToGeneratedContent

extension Array: ConvertibleToGeneratedContent where Element: ConvertibleToGeneratedContent {
    /// An instance that represents the generated content.
    public var generatedContent: GeneratedContent {
        let elements = self.map { $0.generatedContent }
        // Create a JSON array representation
        let jsonArray = elements.map { $0.text }
        let jsonString = "[\(jsonArray.map { "\"\($0)\"" }.joined(separator: ", "))]"
        return GeneratedContent(jsonString)
    }
}

// MARK: - Array ConvertibleFromGeneratedContent

extension Array: ConvertibleFromGeneratedContent where Element: ConvertibleFromGeneratedContent {
    /// Creates an instance with the content.
    public init(_ content: GeneratedContent) throws {
        // Try to parse as JSON array
        if let elements = try? content.elements() {
            self = try elements.map { try Element($0) }
        } else {
            // Fallback: try to split by common separators
            let text = content.text.trimmingCharacters(in: .whitespacesAndNewlines)
            if text.hasPrefix("[") && text.hasSuffix("]") {
                // Remove brackets and split
                let inner = String(text.dropFirst().dropLast())
                let parts = inner.split(separator: ",").map { String($0.trimmingCharacters(in: .whitespacesAndNewlines)) }
                self = try parts.map { try Element(GeneratedContent($0)) }
            } else {
                // Try splitting by newlines or commas
                let parts = text.split(whereSeparator: { $0.isNewline || $0 == "," })
                    .map { String($0.trimmingCharacters(in: .whitespacesAndNewlines)) }
                    .filter { !$0.isEmpty }
                self = try parts.map { try Element(GeneratedContent($0)) }
            }
        }
    }
}