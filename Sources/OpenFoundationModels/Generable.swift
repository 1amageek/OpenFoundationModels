import Foundation

/// Protocol for types that can be generated by a language model
public protocol Generable: Sendable {
    /// The JSON schema describing this type's structure
    static var schema: JSONSchema { get }
    
    /// Create an instance from generated content
    /// - Parameter content: The generated JSON string
    /// - Returns: An instance of this type
    static func fromGeneratedContent(_ content: String) throws -> Self
    
    /// Convert an instance to generated content
    /// - Returns: A JSON string representation
    func toGeneratedContent() throws -> String
}

/// Represents a JSON schema for structured generation
public struct JSONSchema: Sendable {
    /// The schema type
    public let type: SchemaType
    
    /// Properties for object types
    public let properties: [String: JSONSchema]?
    
    /// Required properties for object types
    public let required: [String]?
    
    /// Items schema for array types
    public let items: Box<JSONSchema>?
    
    /// Description of the schema
    public let description: String?
    
    /// Additional constraints
    public let constraints: SchemaConstraints?
    
    public init(
        type: SchemaType,
        properties: [String: JSONSchema]? = nil,
        required: [String]? = nil,
        items: JSONSchema? = nil,
        description: String? = nil,
        constraints: SchemaConstraints? = nil
    ) {
        self.type = type
        self.properties = properties
        self.required = required
        self.items = items.map(Box.init)
        self.description = description
        self.constraints = constraints
    }
}

/// Box type to work around recursive value types
public final class Box<T>: @unchecked Sendable {
    public let value: T
    
    public init(_ value: T) {
        self.value = value
    }
}

/// JSON schema types
public enum SchemaType: String, Sendable {
    case object
    case array
    case string
    case number
    case integer
    case boolean
    case null
}

/// Constraints for schema validation
public struct SchemaConstraints: Sendable {
    /// Minimum value for numbers
    public let minimum: Double?
    
    /// Maximum value for numbers
    public let maximum: Double?
    
    /// Pattern for string validation
    public let pattern: String?
    
    /// Minimum length for strings/arrays
    public let minLength: Int?
    
    /// Maximum length for strings/arrays
    public let maxLength: Int?
    
    /// Enum values
    public let enumValues: [String]?
    
    public init(
        minimum: Double? = nil,
        maximum: Double? = nil,
        pattern: String? = nil,
        minLength: Int? = nil,
        maxLength: Int? = nil,
        enumValues: [String]? = nil
    ) {
        self.minimum = minimum
        self.maximum = maximum
        self.pattern = pattern
        self.minLength = minLength
        self.maxLength = maxLength
        self.enumValues = enumValues
    }
}